
<!-- Created: 26/08/2025 by Yann Kerhervé -->
<!-- Last Version 20/10/2025 including highlight functions -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>C18LW - OCR</title>
<link rel="icon" type="image/png" href="facion.png">
<style>
  :root {
    --bg: #f4f4f4;
    --panel: #fff;
    --muted: #666;
    --accent: #007bff;
    --radius: 8px;
    --shadow: 0 0 10px rgba(0,0,0,0.1);
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: var(--bg);
    color: #333;
  }



     /* Bouton flottant */
    .menu-wrapper {
      position: fixed;
      top: 1rem;
      left: 1rem;
      z-index: 50;
    }
/* Bouton Info flottant à droite */
.meta-wrapper {
  position: fixed;
  top: 1rem;
  right: 1rem;   /* bouton collé au bord droit */
  z-index: 50;
}

/* Menu déroulant du bouton Info à droite */
.meta-wrapper .menu-panel {
  position: absolute;  /* nécessaire pour pouvoir placer le menu */
  top: 100%;           /* juste en dessous du bouton */
  right: 0;            /* bord droit du menu aligné sur le bouton */
  left: auto;          /* annule tout left hérité */
  width: 400px;        /* largeur du panneau */
  text-align: left;    /* texte à gauche dans le panneau */
  margin-top: 0.5rem;  /* petit espace sous le bouton */
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.4s ease;
}
.meta-wrapper .menu-panel.open {
  max-height: 500px;   /* même transition que pour le menu principal */
}


    .menu-button {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgba(255, 255, 255, 0.9);
      color: black; /* texte noir */
      border-radius: 0.5rem;
      padding: 0.5rem;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      cursor: pointer;
      transition: background 0.3s;
      width: 60px;
    }

    .menu-button:hover {
      background: rgba(255, 255, 255, 1);
    }

    .menu-button img {
      margin-bottom: 0.25rem;
      width: 2.5rem;
      height: 2.5rem;
    }

    .menu-button span {
      font-size: 0.875rem;
      font-weight: 600;
      color: black; /* bien noir */
    }

    /* Menu déroulant */
    .menu-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease;
      margin-top: 0.5rem;
    }

    .menu-panel.open {
      max-height: 500px;
    }

    .menu-section {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      display: flex;
      flex-direction: column;
    }

    .menu-section a {
      display: block;
      padding: 0.5rem 0.75rem;
      border-radius: 0.25rem;
      color: black; /* texte noir */
      text-decoration: none;
      transition: background 0.2s;
    }

    .menu-section a:hover {
      background: #e5e7eb; /* gris clair */
      color: black; /* reste noir */
    }



  header {
    text-align: center;
    padding: 16px 20px;
    border-bottom: 2px solid #eee;
    margin-bottom: 20px;
  }

  header h1 {
    font-size: 22px;
    margin: 0;
    font-weight: bold;
    color: #444;
  }

  .controls {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    padding: 12px 20px;
    align-items: center;
    justify-content: center;
  }

  .controls .group {
    background: var(--panel);
    padding: 10px 12px;
    border-radius: var(--radius);
    display: flex;
    align-items: center;
    gap: 8px;
    box-shadow: var(--shadow);
    border: 1px solid #ddd;
  }

  label {
    font-size: 14px;
    color: var(--muted);
  }

  input[type="number"] {
    border-radius: 5px;
    border: 1px solid #ddd;
    background: #fafafa;
    color: #333;
    padding: 6px 8px;
    min-width: 72px;
    font-size: 14px;
  }

  input[type="range"] {
    accent-color: var(--accent);
  }

  button {
    background: var(--accent);
    color: #fff;
    border: none;
    padding: 8px 16px;
    border-radius: 5px;
    font-weight: bold;
    cursor: pointer;
    transition: background-color 0.3s, opacity 0.3s;
  }

  button:hover:enabled {
    background-color: #0056b3;
  }

  button:disabled {
    background-color: #6c757d;
    cursor: not-allowed;
  }

  .split {
    display: grid;
    grid-template-columns: 60% 40%;
    gap: 20px;
    padding: 0 20px 24px;
    height: calc(100vh - 100px);
    max-width: 1200px;
    margin: 0 auto;
  }

  .panel {
    background: var(--panel);
    border-radius: var(--radius);
    overflow: hidden;
    display: flex;
    flex-direction: column;
    min-height: 0;
    box-shadow: var(--shadow);
    border: 1px solid #ddd;
  }

  .panel h3 {
    margin: 0;
    padding: 12px;
    border-bottom: 1px solid #eee;
    font-size: 14px;
    letter-spacing: .3px;
    color: var(--muted);
    background: #fafafa;
  }

  .panel .body {
    padding: 12px;
    overflow: auto;
    flex: 1;
  }

  #ocrText {
    white-space: pre-wrap;
    font-family: Consolas, Monaco, "Courier New", monospace;
    font-size: 14px;
    line-height: 1.4;
    color: #333;
  }

  #status {
    font-size: 12px;
    color: var(--muted);
    padding: 8px 12px;
    border-top: 1px solid #eee;
    background: #fafafa;
  }

  #pdfCanvas {
    width: 100%;
    height: auto;
    display: block;
    background: #f9f9f9;
    border: 1px solid #ddd;
  }

  .footer {
    text-align: center;
    padding: 16px;
    color: #888;
    font-size: 0.8em;
    border-top: 2px solid #eee;
    margin-top: 20px;
  }

  @media (max-width: 980px) {
    .split {
      grid-template-columns: 1fr;
      height: auto;
    }
  }
</style>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
<!--<header><h1>Secretaires</h1></header>-->
 <!-- Bouton flottant -->
  <div class="menu-wrapper">
    <div id="menuToggle" class="menu-button">
      <img src="c18lw.png" alt="Logo">
      <span>Menu</span>
    </div>

    <!-- Contenu du menu -->
    <div id="menuContent" class="menu-panel">
      <!-- Bloc 1 -->
      <div class="menu-section">
        <a href="index.htm">Home</a>
        <a href="database.htm">Data Base</a>
        <a href="resultatrecherche.htm">Advanced Search</a>
      </div>
      <!-- Bloc 2 -->
      <div class="menu-section">
        <a id="viewpdf" href="#">View PDF</a>
        <a id="viewtxt" href="#">View Text</a>
        <a id="viewocr" href="#">View OCR</a>
      </div>
    </div>
  </div>


  <!-- Bouton flottant métadonnées -->
  <div class="meta-wrapper">
    <div id="metaToggle" class="menu-button">
      <img src="info.png" alt="Info">
      <span>Info</span>
    </div>

    <!-- Contenu des métadonnées -->
    <div id="metaContent" class="menu-panel">
      <div class="menu-section" id="metadataBox">
        Loading metadata...
      </div>
    </div>
  </div>




<div class="controls">
  <div class="group">
    <label for="pageNumber">Page</label>
    <input type="number" id="pageNumber" min="1" value="1" />
    <span>/ <span id="pageCount">0</span></span>
    <input type="range" id="pageSlider" min="1" value="1" step="1" style="width:200px;" />
  </div>
  <div class="group">
    <label for="zoom">Zoom rendered</label>
    <input type="range" id="zoom" min="1" max="3" step="0.25" value="2" />
    <span id="zoomVal">2.00×</span>
  </div>
  <div class="group">
    <button id="rerunOcr" disabled>Restart OCR</button>
    <button id="aiCorrectionBtn" disabled>Correct with AI</button>
  </div>
</div>

<div class="split">
  <section class="panel">
    <h3>PDF preview</h3>
    <div class="body"><canvas id="pdfCanvas"></canvas></div>
  </section>
  <section class="panel">
    <h3>OCR transcription (current page)</h3>
    <div class="body" id="ocrText"></div>
    <div id="status">Specify a PDF via URL ?pdf=fichier.pdf</div>
  </section>
</div>

<div class="footer">
  Tip: add `?pdf=mylibrary.pdf&page=3` to the URL to open page 3 directly.
</div>

<!-- Librairies -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
<script>pdfjsLib.GlobalWorkerOptions.workerSrc="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";</script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

<script>


let ocrLang = 'eng';        // langue Tesseract
let grammarLang = 'en-US'; // langue LanguageTool

const $=sel=>document.querySelector(sel);
const pageNumber=$('#pageNumber'), pageSlider=$('#pageSlider'), pageCountEl=$('#pageCount');
const pdfCanvas=$('#pdfCanvas'), ocrText=$('#ocrText'), statusEl=$('#status');
const zoom=$('#zoom'), zoomVal=$('#zoomVal');
const rerunBtn=$('#rerunOcr'), aiBtn=$('#aiCorrectionBtn');
const viewpdfElement = document.getElementById('viewpdf');
const viewtxtElement = document.getElementById('viewtxt');
const viewocrElement = document.getElementById('viewocr');

let pdfDoc=null, currentPage=1, scale=2.0, pageCount=0;
const pageCache=new Map();

// --------- URL Params ----------
const params=new URLSearchParams(window.location.search);
const pdfUrl=params.get('pdf');
let startPage=parseInt(params.get('page')||'1',10);

// --------- PDF Handling ----------
pageNumber.addEventListener('change', onPageNumberChange);
pageSlider.addEventListener('input', onPageSliderChange);
zoom.addEventListener('input', ()=>{scale=parseFloat(zoom.value);zoomVal.textContent=scale.toFixed(2)+'×';if(pdfDoc) renderAndOcr(currentPage,false);});
rerunBtn.addEventListener('click',()=>runOcr(true));
aiBtn.addEventListener('click',async()=>{ocrText.textContent=await applyAiCorrection(ocrText.textContent);});

if(pdfUrl){ openPdf(pdfUrl); }

viewpdfElement.href = `${pdfUrl}`;
viewtxtElement.href = `txt.htm?pdf=${pdfUrl}`;
viewocrElement.href = `ocr.htm?pdf=${pdfUrl}`;

// --------- Open PDF ----------
async function openPdf(url){
  resetUI();
  const task=pdfjsLib.getDocument(url);
  statusEl.textContent='Loading PDF...';
  try{
    pdfDoc=await task.promise;
    pageCount=pdfDoc.numPages;
    pageCountEl.textContent=pageCount;
    startPage=Math.min(Math.max(1,startPage),pageCount);
    pageNumber.value=startPage;
    pageSlider.max=pageCount; pageSlider.value=startPage;
    rerunBtn.disabled=false; aiBtn.disabled=false;
    statusEl.textContent=`PDF loaded (${pageCount} pages). Rendu + OCR…`;
    await renderAndOcr(startPage,true);
  }catch(e){ statusEl.textContent='Loading error : '+e.message; }
}

// --------- Render ----------
async function renderPage(num){
  const page=await pdfDoc.getPage(num);
  const viewport=page.getViewport({scale});
  const ctx=pdfCanvas.getContext('2d');
  pdfCanvas.width=Math.floor(viewport.width);
  pdfCanvas.height=Math.floor(viewport.height);
  await page.render({canvasContext:ctx,viewport}).promise;
}
function cacheKey(num=currentPage){ return `${num}-eng-${scale.toFixed(2)}`; }

// --------- OCR ----------
async function applyAiCorrection(text){
  try{
    const resp=await fetch("https://api.languagetool.org/v2/check",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams({text:text,language:grammarLang})});
    const result=await resp.json();
    let corrected=text;
    result.matches.sort((a,b)=>b.offset-a.offset).forEach(m=>{
      if(m.replacements && m.replacements.length>0)
        corrected=corrected.slice(0,m.offset)+m.replacements[0].value+corrected.slice(m.offset+m.length);
    });
    return corrected;
  }catch(e){console.warn("Erreur LanguageTool:",e);return text;}
}
async function runOcr(force=false){
  const key=cacheKey();
  if(!force && pageCache.has(key)){ ocrText.textContent=pageCache.get(key); statusEl.textContent='Depuis cache.'; return; }
  statusEl.textContent='OCR en cours…';
  try{
    const {data}=await Tesseract.recognize(pdfCanvas,ocrLang,{logger:m=>{if(m.status)statusEl.textContent=`${m.status} ${m.progress?Math.round(m.progress*100)+'%':''}`;}});
    let text=(data && data.text ? data.text.trim() : '');
    text=await applyAiCorrection(text);
    pageCache.set(key,text);
    ocrText.textContent=text||'(no text detected)';
const query = params.get('query');
const fuzz = parseFloat(params.get('fuzz') || '0.8'); // 0.8 = 80% de similarité minimale

if (query) {
  const text = ocrText.textContent;

  // Fonction de similarité simple (basée sur Levenshtein)
  function similarity(a, b) {
    const dp = Array(a.length + 1).fill(null).map(() => Array(b.length + 1).fill(0));
    for (let i = 0; i <= a.length; i++) dp[i][0] = i;
    for (let j = 0; j <= b.length; j++) dp[0][j] = j;
    for (let i = 1; i <= a.length; i++) {
      for (let j = 1; j <= b.length; j++) {
        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
        dp[i][j] = Math.min(
          dp[i - 1][j] + 1,
          dp[i][j - 1] + 1,
          dp[i - 1][j - 1] + cost
        );
      }
    }
    const dist = dp[a.length][b.length];
    return 1 - dist / Math.max(a.length, b.length);
  }

  let best = { score: 0, start: -1, end: -1 };
  const len = query.length;
  for (let i = 0; i < text.length - len; i++) {
    const sub = text.slice(i, i + len + 10); // marge pour variations
    const s = similarity(query.toLowerCase(), sub.toLowerCase());
    if (s > best.score) best = { score: s, start: i, end: i + len };
  }

  if (best.score >= fuzz) {
    const mid = best.start + 10 + Math.floor((best.end - best.start - len) / 2);
    const before = text.slice(0, mid);
    const match = text.slice(mid, mid + len);
    const after = text.slice(mid + len);



    ocrText.innerHTML = `${before}<mark style="background:yellow;">${match}</mark>${after}`;
    statusEl.textContent += ` | Highlighted (similarity ${(best.score*100).toFixed(1)}%)`;
  } else {
    statusEl.textContent += ` | No match above ${(fuzz*100).toFixed(0)}% similarity`;
  }
}

if (query && data.words && data.words.length > 0) {
  const ctx = pdfCanvas.getContext('2d');
  ctx.save();

  // Style visible
  ctx.fillStyle = 'rgba(255, 255, 0, 0.45)';
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.lineWidth = 2;

  // Fonction de similarité simple
  function similarity(a, b) {
    const len = Math.max(a.length, b.length);
    let same = 0;
    for (let i = 0; i < Math.min(a.length, b.length); i++)
      if (a[i].toLowerCase() === b[i].toLowerCase()) same++;
    return same / len;
  }

  // Split query en mots
  const queryWords = query.trim().split(/\s+/);
  const n = queryWords.length;

  let best = { words: null, score: 0 };
  for (let i = 0; i <= data.words.length - n; i++) {
    const seq = data.words.slice(i, i + n);
    const seqText = seq.map(w => w.text).join(' ');
    const s = similarity(query, seqText);
    if (s > best.score) best = { words: seq, score: s };
  }

  if (best.words && best.score >= fuzz) {
    // Rectangle englobant tous les mots de la séquence
    const x0 = Math.min(...best.words.map(w => w.bbox.x0));
    const y0 = Math.min(...best.words.map(w => w.bbox.y0));
    const x1 = Math.max(...best.words.map(w => w.bbox.x1));
    const y1 = Math.max(...best.words.map(w => w.bbox.y1));

    const x = x0;
    const w = x1 - x0;
    const h = y1 - y0;
    const y = y0; // inversion Y

    ctx.fillRect(x - 2, y - 2, w + 4, h + 4);
    ctx.strokeRect(x - 2, y - 2, w + 4, h + 4);

    statusEl.textContent += ` | PDF highlight (score ${(best.score * 100).toFixed(1)}%)`;
  } else {
    statusEl.textContent += ` | No PDF match above ${(fuzz * 100).toFixed(0)}%`;
  }

  ctx.restore();
}






    statusEl.textContent='OCR over.';
  }catch(e){ statusEl.textContent='OCR error : '+e.message; }
}
async function renderAndOcr(num,forceOcr=false){currentPage=num;await renderPage(num);await runOcr(forceOcr);}
function onPageNumberChange(){let num=parseInt(pageNumber.value,10)||1;num=Math.min(Math.max(1,num),pageCount||1);pageNumber.value=num;pageSlider.value=num;if(pdfDoc)renderAndOcr(num,false);}
function onPageSliderChange(){const num=parseInt(pageSlider.value,10)||1;pageNumber.value=num;if(pdfDoc)renderAndOcr(num,false);}
function resetUI(){pdfDoc=null;currentPage=1;pageCount=0;pageCache.clear();pageNumber.value=1;pageSlider.value=1;pageCountEl.textContent='0';ocrText.textContent='';statusEl.textContent='Spécifiez un PDF via l’URL ?pdf=fichier.pdf';rerunBtn.disabled=true;aiBtn.disabled=true;const ctx=pdfCanvas.getContext('2d');ctx.clearRect(0,0,pdfCanvas.width,pdfCanvas.height);}
</script>

  <script>
    const toggleBtn = document.getElementById('menuToggle');
    const menu = document.getElementById('menuContent');

    toggleBtn.addEventListener('click', () => {
      menu.classList.toggle('open');
    });

    // --- Toggle métadonnées ---
const metaBtn = document.getElementById('metaToggle');
const metaPanel = document.getElementById('metaContent');
metaBtn.addEventListener('click', () => {
  metaPanel.classList.toggle('open');
});

// --- Charger métadonnées ---
if(pdfUrl){
  fetch('sec.txt')
    .then(r=>r.text())
    .then(text=>{
      let pythonLike=text.trim();
      if(!pythonLike.startsWith('[')){ pythonLike='['+pythonLike+']'; }
      let metadataList=eval(pythonLike);
      const meta=metadataList.find(m=>m.filename===pdfUrl);
      const box=document.getElementById('metadataBox');
      if (meta) {
        // --- Choix langue OCR ---
        if (meta.pays && meta.pays.toLowerCase() === 'france') {
          ocrLang = 'fra';
          grammarLang = 'fr';
        } else {
          ocrLang = 'eng';
          grammarLang = 'en-US';
        }
      
        box.innerHTML = `
          <strong>Title:</strong> ${meta.title}<br>
          <strong>Author:</strong> ${meta.author}<br>
          <strong>Date:</strong> ${meta.date}<br>
          <strong>Edition:</strong> ${meta.edition}<br>
          <strong>Country:</strong> ${meta.pays}<br>
          <strong>OCR language:</strong> ${ocrLang.toUpperCase()}
        `;
      } else {
        box.textContent="No metadata found for this file.";
      }
    })
    .catch(e=>{
      document.getElementById('metadataBox').textContent="Error loading metadata.";
    });
}

  </script>
  <script>
  // Utilisation de variables locales pour éviter les conflits globaux
  (function() {
    const SB_URL = "https://vxcgquyvndvnnzpvbabw.supabase.co";
    const SB_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ4Y2dxdXl2bmR2bm56cHZiYWJ3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjgwNjUyNDYsImV4cCI6MjA4MzY0MTI0Nn0.yUi9FBmQHR85doK7CyIS2VFyzZXavmD_dbNcKPEp0A4";

    // ✅ On change le nom de la constante pour éviter l'erreur "already declared"
    // On accède à l'objet de la bibliothèque via "supabase.createClient" 
    // car le CDN expose l'objet 'supabase'
    const myAppClient = supabase.createClient(SB_URL, SB_KEY);

    async function protectPage() {
      // 1. Vérifier si l'utilisateur est connecté
      const { data: { session }, error } = await myAppClient.auth.getSession();

      if (error || !session) {
        window.location.href = "login.htm";
        return;
      }

      // 2. Vérifier si le profil est approuvé
      const user = session.user;
      const { data, error: profileError } = await myAppClient
        .from("profiles")
        .select("approved")
        .eq("id", user.id)
        .single();

      if (profileError || !data || data.approved !== true) {
        alert("Your account is not yet approved by the administrator.");
        await myAppClient.auth.signOut();
        window.location.href = "login.htm";
      }
    }

    // Lancer la protection au chargement
    protectPage();
  })();
</script>
</body>
</html>




